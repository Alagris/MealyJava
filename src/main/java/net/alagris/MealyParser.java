/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package net.alagris;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.PrimitiveIterator.OfInt;

import org.antlr.v4.runtime.BaseErrorListener;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.tree.TerminalNode;

import net.alagris.GrammarBaseVisitor;
import net.alagris.GrammarLexer;
import net.alagris.GrammarParser;
import net.alagris.GrammarParser.AlphDefContext;
import net.alagris.GrammarParser.AtomicLiteralContext;
import net.alagris.GrammarParser.AtomicNestedContext;
import net.alagris.GrammarParser.AtomicRangeContext;
import net.alagris.GrammarParser.AtomicVarIDContext;
import net.alagris.GrammarParser.EndConcatContext;
import net.alagris.GrammarParser.EndFuncsContext;
import net.alagris.GrammarParser.EndParamsContext;
import net.alagris.GrammarParser.EndUnionContext;
import net.alagris.GrammarParser.EpsilonProductContext;
import net.alagris.GrammarParser.FuncDefContext;
import net.alagris.GrammarParser.KleeneClosureContext;
import net.alagris.GrammarParser.MoreConcatContext;
import net.alagris.GrammarParser.MoreParamsContext;
import net.alagris.GrammarParser.MoreUnionContext;
import net.alagris.GrammarParser.NestedTypeContext;
import net.alagris.GrammarParser.NoKleeneClosureContext;
import net.alagris.GrammarParser.ProductContext;
import net.alagris.GrammarParser.StartContext;
import net.alagris.GrammarParser.TypeAtomicContext;
import net.alagris.GrammarParser.TypeDefContext;
import net.alagris.GrammarParser.TypeFuncContext;
import net.alagris.GrammarParser.TypeVarContext;
import net.alagris.Simple.A;
import net.alagris.WithVars.V;

public class MealyParser {
    static void repeat(StringBuilder sb, String s, int times) {
        while (times-- > 0) {
            sb.append(s);
        }
    }

    static void ind(StringBuilder sb, int indent) {
        repeat(sb, "    ", indent);
    }

    public static int escapeCharacter(int c) {
        switch (c) {
        case 'b':
            return '\b';
        case 'n':
            return '\n';
        case 'r':
            return '\r';
        case 't':
            return '\t';
        case 'f':
            return '\f';
        default:
            return c;
        }
    }

    interface AST {

    }

    static class Params implements AST {
        final ArrayList<String> params = new ArrayList<>();
    }

    static class Funcs implements AST {
        final ArrayList<Func> funcs = new ArrayList<>();
        final HashMap<String, Alphabet> alphabets = new HashMap<>();
        final HashMap<String, Type> types = new HashMap<>();
    }

    static interface Type extends AST {

    }

    static class TypeFunc implements Type {
        final Type lhs, rhs;

        public TypeFunc(Type lhs, Type rhs) {
            this.rhs = rhs;
            this.lhs = lhs;
        }
    }

    static class TypeVar implements Type {
        final String var;

        TypeVar(String var) {
            this.var = var;
        }
    }

    static class Func implements AST {
        final String name;
        final String[] vars;
        final V body;

        public Func(String name, String[] vars, V body) {
            this.name = name;
            this.vars = vars;
            this.body = body;
        }

    }

    interface Alph extends AST {
        
        public String name();
        
        public int map(int unicode);

        public IntArrayList map(String literal);
    }

    static class Alphabet implements Alph {
        final HashMap<Integer, Integer> unicodeToIndex = new HashMap<>();
        final String name;
        public Alphabet(String name,String literal) {
            this.name = name;
            int index = 1;
            for (int codepoint : (Iterable<Integer>) () -> literal.subSequence(1, literal.length() - 1).codePoints()
                    .iterator()) {
                if(null!=unicodeToIndex.put(codepoint, index++)) {
                    throw new IllegalStateException("Alphabet "+name+" contains letter "+(char)codepoint+" twice!");
                }
            }
        }

        @Override
        public int map(int unicode) {
            Integer out = unicodeToIndex.get(unicode);
            if (out == null)
                throw new IllegalStateException(
                        "Character '" + (char) unicode + "' (unicode " + unicode + ") doesn't belong to alphabet!");
            return out;
        }

        @Override
        public IntArrayList map(String literal) {
            return new IntArrayList(literal.codePointCount(0, literal.length()), new OfInt() {
                OfInt i = literal.codePoints().iterator();

                @Override
                public boolean hasNext() {
                    return i.hasNext();
                }

                @Override
                public int nextInt() {
                    return map(i.next());
                }

            });
        }

        @Override
        public String name() {
            return name;
        }
    }

    public static final Alph UNICODE = new Alph() {

        @Override
        public IntArrayList map(String literal) {
            return new IntArrayList(literal.codePointCount(0, literal.length()), literal.codePoints().iterator());
        }

        @Override
        public int map(int unicode) {
            return unicode;
        }

        @Override
        public String name() {
            return "UNICODE";
        }
    };

    private static class GrammarVisitor extends GrammarBaseVisitor<AST> {

        @Override
        public AST visitEndParams(EndParamsContext ctx) {
            return new Params();
        }

        @Override
        public AST visitMoreParams(MoreParamsContext ctx) {
            Params params = (Params) visit(ctx.params());
            params.params.add(ctx.ID().getText());
            return params;
        }

        @Override
        public AST visitTypeVar(TypeVarContext ctx) {
            return new TypeVar(ctx.ID().getText());
        }

        @Override
        public AST visitTypeFunc(TypeFuncContext ctx) {
            return new TypeFunc((Type) visit(ctx.atomic_type()), (Type) visit(ctx.type()));
        }

        @Override
        public AST visitTypeAtomic(TypeAtomicContext ctx) {
            return visit(ctx.atomic_type());
        }

        @Override
        public AST visitNestedType(NestedTypeContext ctx) {
            return visit(ctx.type());
        }

        @Override
        public AST visitEndFuncs(EndFuncsContext ctx) {
            return new Funcs();
        }

        @Override
        public AST visitTypeDef(TypeDefContext ctx) {
            Funcs funcs = (Funcs) visit(ctx.funcs());
            Type type = (Type) visit(ctx.type());
            final String id = ctx.ID().getText();
            if (null != funcs.types.put(id, type)) {
                throw new IllegalStateException("Type of " + id + " redeclared!");
            }
            return funcs;
        }

        @Override
        public AST visitAlphDef(AlphDefContext ctx) {
            Funcs funcs = (Funcs) visit(ctx.funcs());
            final String id = ctx.ID().getText();
            if (null != funcs.alphabets.put(id, new Alphabet(id,ctx.Alph().getText()))) {
                throw new IllegalStateException("Alphabet " + id + " redeclared!");
            }
            return funcs;
        }

        @Override
        public AST visitFuncDef(FuncDefContext ctx) {
            Funcs funcs = (Funcs) visit(ctx.funcs());
            ArrayList<String> params = ((Params) visit(ctx.params())).params;
            Func f = new Func(ctx.ID().getText(), params.toArray(new String[0]), (V) visit(ctx.mealy_union()));
            funcs.funcs.add(f);
            return funcs;
        }

        @Override
        public AST visitEpsilonProduct(EpsilonProductContext ctx) {
            return visit(ctx.mealy_atomic());
        }

        @Override
        public AST visitAtomicVarID(AtomicVarIDContext ctx) {
            return new WithVars.Var(ctx.ID().getText());
        }

        @Override
        public AST visitAtomicNested(AtomicNestedContext ctx) {
            return visit(ctx.mealy_union());
        }

        private String parseQuotedLiteral(String literal) {
            final String unquotedLiteral = literal.substring(1, literal.length() - 1);
            final char[] escaped = new char[unquotedLiteral.length()];
            int j = 0;
            boolean isAfterBackslash = false;
            for (int i = 0; i < unquotedLiteral.length(); i++) {
                final char c = unquotedLiteral.charAt(i);
                if (isAfterBackslash) {
                    switch (c) {
                    case '0':
                        throw new IllegalStateException("Null character \\0 is not allowed!");
                    case 'b':
                        escaped[j++] = '\b';
                        break;
                    case 't':
                        escaped[j++] = '\t';
                        break;
                    case 'n':
                        escaped[j++] = '\n';
                        break;
                    case 'r':
                        escaped[j++] = '\r';
                        break;
                    case 'f':
                        escaped[j++] = '\f';
                        break;
                    default:
                        escaped[j++] = c;
                        break;
                    }
                    isAfterBackslash = false;
                } else {
                    switch (c) {
                    case '\\':
                        isAfterBackslash = true;
                        break;
                    case '#':
                        escaped[j++] = 0;
                        break;
                    default:
                        escaped[j++] = c;
                        break;
                    }

                }
            }
            return new String(escaped, 0, j);
        }

        @Override
        public AST visitProduct(ProductContext ctx) {
            return new WithVars.Product((V) visit(ctx.mealy_atomic()),
                    parseQuotedLiteral(ctx.StringLiteral().getText()));
        }

        @Override
        public AST visitAtomicLiteral(AtomicLiteralContext ctx) {
            return new WithVars.Atomic(parseQuotedLiteral(ctx.StringLiteral().getText()));
        }

        @Override
        public AST visitNoKleeneClosure(NoKleeneClosureContext ctx) {
            return visit(ctx.mealy_prod());
        }

        @Override
        public AST visitKleeneClosure(KleeneClosureContext ctx) {
            final TerminalNode w = ctx.Weight();
            V nested = (V) visit(ctx.mealy_prod());
            if (w == null) {
                return new WithVars.Kleene(nested);
            } else {
                final int i = Integer.parseInt(w.getText());
                return new WithVars.Kleene(new WithVars.WeightAfter(nested, i));
            }
        }

        @Override
        public AST visitEndConcat(EndConcatContext ctx) {
            final TerminalNode w = ctx.Weight();
            V lhs = (V) visit(ctx.mealy_Kleene_closure());
            if (w == null) {
                return lhs;
            } else {
                final int i = Integer.parseInt(w.getText());
                return new WithVars.WeightAfter(lhs, i);
            }
        }

        @Override
        public AST visitMoreConcat(MoreConcatContext ctx) {
            V lhs = (V) visit(ctx.mealy_Kleene_closure());
            V rhs = (V) visit(ctx.mealy_concat());

            final TerminalNode w = ctx.Weight();
            if (w == null) {
                return new WithVars.Concat(lhs, rhs);
            } else {
                final int i = Integer.parseInt(w.getText());
                return new WithVars.Concat(new WithVars.WeightAfter(lhs, i), rhs);
            }
        }

        @Override
        public AST visitAtomicRange(AtomicRangeContext ctx) {
            final int[] range = ctx.Range().getText().codePoints().toArray();
            final int from, to;
            // [a-b] or [\a-b] or [a-\b] or [\a-\b]
            if (range[1] == '\\') {
                // [\a-b] or [\a-\b]
                from = escapeCharacter(range[2]);
                if (range[4] == '\\') {
                    // [\a-\b]
                    to = escapeCharacter(range[5]);
                } else {
                    // [\a-b]
                    to = range[4];
                }
            } else {
                // [a-b] or [a-\b]
                from = range[1];
                if (range[3] == '\\') {
                    // [a-\b]
                    to = escapeCharacter(range[4]);
                } else {
                    // [a-b]
                    to = range[3];
                }
            }
            return new WithVars.Range(from, to);
        }

        @Override
        public AST visitMoreUnion(MoreUnionContext ctx) {
            V lhs = (V) visit(ctx.mealy_concat());
            V rhs = (V) visit(ctx.mealy_union());

            final TerminalNode w = ctx.Weight();
            if (w == null) {
                return new WithVars.Union(lhs, rhs);
            } else {
                final int i = Integer.parseInt(w.getText());
                return new WithVars.Union(new WithVars.WeightBefore(lhs, i), rhs);
            }
        }

        @Override
        public AST visitEndUnion(EndUnionContext ctx) {
            V lhs = (V) visit(ctx.mealy_concat());
            final TerminalNode w = ctx.Weight();
            if (w == null) {
                return lhs;
            } else {
                final int i = Integer.parseInt(w.getText());
                return new WithVars.WeightBefore(lhs, i);
            }
        }

        @Override
        public AST visitStart(StartContext ctx) {
            return visit(ctx.funcs());
        }
    }

    public static Funcs parse(String source) {
        return parse(CharStreams.fromString(source));
    }

    public static Funcs parse(CharStream source) {

        GrammarLexer lexer = new GrammarLexer(source);
        GrammarParser parser = new GrammarParser(new CommonTokenStream(lexer));
        parser.addErrorListener(new BaseErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line,
                    int charPositionInLine, String msg, RecognitionException e) {
                System.err.println("line " + line + ":" + charPositionInLine + " " + msg + " " + e);
            }
        });
        GrammarVisitor visitor = new GrammarVisitor();
        Funcs funcs = (Funcs) visitor.visit(parser.start());
        return funcs;

    }

    public static class AAA{
        final A ast;
        final String fName;
        final Alph in;
        final Alph out;
        public AAA(String fName,A ast, Alph in, Alph out) {
            this.fName = fName;
            this.ast = ast;
            this.in = in;
            this.out = out;
        }
        
        @Override
        public String toString() {
            return fName+":"+in.name()+"->"+out.name();
        }
        
        
    }
    public static HashMap<String, AAA> eval(Funcs funcs) {
        HashMap<String, AAA> evaluated = new HashMap<>();

        for (Func f : funcs.funcs) {
            final Alph in;
            final Alph out;

            TypeFunc mustBeFunc = (TypeFunc) funcs.types.get(f.name);
            if (mustBeFunc == null) {
                in = UNICODE;
                out = UNICODE;
            } else {
                TypeVar input = (TypeVar) mustBeFunc.lhs;
                TypeVar output = (TypeVar) mustBeFunc.rhs;
                in = funcs.alphabets.get(input.var);
                out = funcs.alphabets.get(output.var);
            }
            evaluated.put(f.name, new AAA(f.name,f.body.substituteVars(evaluated, in, out),in,out));
        }
        return evaluated;
    }
}
