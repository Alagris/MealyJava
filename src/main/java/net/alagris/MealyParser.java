/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package net.alagris;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.PrimitiveIterator.OfInt;

import org.antlr.v4.runtime.BaseErrorListener;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.tree.TerminalNode;

import net.alagris.GrammarParser.AtomicLiteralContext;
import net.alagris.GrammarParser.AtomicNestedContext;
import net.alagris.GrammarParser.AtomicRangeContext;
import net.alagris.GrammarParser.AtomicVarIDContext;
import net.alagris.GrammarParser.EndConcatContext;
import net.alagris.GrammarParser.EndFuncsContext;
import net.alagris.GrammarParser.EndParamsContext;
import net.alagris.GrammarParser.EndUnionContext;
import net.alagris.GrammarParser.EpsilonProductContext;
import net.alagris.GrammarParser.FuncDefContext;
import net.alagris.GrammarParser.KleeneClosureContext;
import net.alagris.GrammarParser.MoreConcatContext;
import net.alagris.GrammarParser.MoreParamsContext;
import net.alagris.GrammarParser.MoreUnionContext;
import net.alagris.GrammarParser.NestedTypeContext;
import net.alagris.GrammarParser.NoKleeneClosureContext;
import net.alagris.GrammarParser.ProductContext;
import net.alagris.GrammarParser.StartContext;
import net.alagris.GrammarParser.TypeDefContext;
import net.alagris.GrammarParser.TypeLanguageContext;
import net.alagris.GrammarParser.TypeVarContext;
import net.alagris.Simple.A;
import net.alagris.learn.__;
import net.alagris.Regex;
import net.alagris.CompilationError.Errors;
import net.alagris.CompilationError.FuncDuplicateBody;
import net.alagris.CompilationError.FuncDuplicateType;

public class MealyParser {
    static void repeat(StringBuilder sb, String s, int times) {
        while (times-- > 0) {
            sb.append(s);
        }
    }

    static void ind(StringBuilder sb, int indent) {
        repeat(sb, "    ", indent);
    }

    public static int escapeCharacter(int c) {
        switch (c) {
        case 'b':
            return '\b';
        case 'n':
            return '\n';
        case 'r':
            return '\r';
        case 't':
            return '\t';
        case 'f':
            return '\f';
        default:
            return c;
        }
    }

    interface AST {

    }

    static class Funcs implements AST {
        private final HashMap<String, Func> funcs = new HashMap<>();
        private final ArrayList<Func> funcsInOppositeOrderOfDefinition = new ArrayList<>();

        public Funcs prepend(String funcName, Regex funcBody, SourceCodePosition pos) {
            funcsInOppositeOrderOfDefinition.add(funcs.computeIfAbsent(funcName, Func::new).assign(funcBody, pos));
            return this;
        }

        public Funcs prepend(String funcName, Type funcType, SourceCodePosition pos) {
            funcsInOppositeOrderOfDefinition.add(funcs.computeIfAbsent(funcName, Func::new).assign(funcType, pos));
            return this;
        }

        public Funcs prepend(String funcName, Type funcType, Regex funcBody, SourceCodePosition pos) {
            funcsInOppositeOrderOfDefinition
                    .add(funcs.computeIfAbsent(funcName, Func::new).assign(funcType, funcBody, pos));
            return this;
        }

        public Funcs prependIfNotPresent(String funcName, TypeLanguage funcType, Regex funcBody, SourceCodePosition pos) {
            if (!funcs.containsKey(funcName)) {
                prepend(funcName, funcType, funcBody, pos);
            }
            return this;
        }
    }

    static interface Type extends AST {

    }

    static class TypeRelation implements Type {
        final Regex lhs, rhs;

        public TypeRelation(Regex lhs, Regex rhs) {
            this.rhs = rhs;
            this.lhs = lhs;
        }
    }

    static class TypeLanguage implements Type {
        final Regex lang;

        TypeLanguage(Regex lang) {
            this.lang = lang;
        }
    }

    static class Func {
        private final String name;
        private Regex body;
        private Type type;
        SourceCodePosition bodyPos, typePos;

        public Func(String name) {
            this.name = name;
        }

        public Func assign(Type funcType, Regex funcBody, SourceCodePosition pos) {
            return assign(funcType, pos).assign(funcBody, pos);
        }

        public Func assign(Regex funcBody, SourceCodePosition pos) {
            if (body == null) {
                bodyPos = pos;
                body = funcBody;
                return this;
            } else {
                throw new FuncDuplicateBody(bodyPos, pos, name);
            }
        }

        public Func assign(Type funcType, SourceCodePosition pos) {
            if (type == null) {
                typePos = pos;
                type = funcType;
                return this;
            } else {
                throw new FuncDuplicateType(typePos, pos, name);
            }
        }

        public String getName() {
            return name;
        }

    }

    private static class GrammarVisitor extends GrammarBaseVisitor<AST> {

        @Override
        public AST visitTypeLanguage(TypeLanguageContext ctx) {
            return new TypeLanguage((Regex) visit(ctx.mealy_union()));
        }

        @Override
        public AST visitEndFuncs(EndFuncsContext ctx) {
            return new Funcs();
        }

        @Override
        public AST visitTypeDef(TypeDefContext ctx) {
            final Funcs funcs = (Funcs) visit(ctx.funcs());
            final Type funcType = (Type) visit(ctx.type());
            final String funcName = ctx.ID().getText();
            return funcs.prepend(funcName, funcType, new SourceCodePosition(ctx.ID().getSymbol()));
        }

        @Override
        public AST visitFuncDef(FuncDefContext ctx) {
            final Funcs funcs = (Funcs) visit(ctx.funcs());
            final String funcName = ctx.ID().getText();
            final Regex funcBody = (Regex) visit(ctx.mealy_union());
            return funcs.prepend(funcName, funcBody, new SourceCodePosition(ctx.ID().getSymbol()));
        }

        @Override
        public AST visitEpsilonProduct(EpsilonProductContext ctx) {
            return visit(ctx.mealy_atomic());
        }

        @Override
        public AST visitAtomicVarID(AtomicVarIDContext ctx) {
            return new Regex.Var(ctx.ID().getText(), new SourceCodePosition(ctx.ID().getSymbol()));
        }

        @Override
        public AST visitAtomicNested(AtomicNestedContext ctx) {
            return visit(ctx.mealy_union());
        }

        private __.S<Integer> parseQuotedLiteral(TerminalNode literal) {
            final String quotedLiteral = literal.getText();
            final String unquotedLiteral = quotedLiteral.substring(1, quotedLiteral.length() - 1);
            final int[] escaped = new int[unquotedLiteral.length()];
            int j = 0;
            boolean isAfterBackslash = false;
            for (int c : (Iterable<Integer>) unquotedLiteral.codePoints()::iterator) {
                if (isAfterBackslash) {
                    switch (c) {
                    case '0':
                        throw new CompilationError.IllegalCharacter(new SourceCodePosition(literal.getSymbol()), "\\0");
                    case 'b':
                        escaped[j++] = '\b';
                        break;
                    case 't':
                        escaped[j++] = '\t';
                        break;
                    case 'n':
                        escaped[j++] = '\n';
                        break;
                    case 'r':
                        escaped[j++] = '\r';
                        break;
                    case 'f':
                        escaped[j++] = '\f';
                        break;
                    case '#':
                        escaped[j++] = '#';
                        break;
                    default:
                        escaped[j++] = c;
                        break;
                    }
                    isAfterBackslash = false;
                } else {
                    switch (c) {
                    case '\\':
                        isAfterBackslash = true;
                        break;
                    case '#':
                        escaped[j++] = 0;
                        break;
                    default:
                        escaped[j++] = c;
                        break;
                    }

                }
            }
            return __.S.arrIntLen(escaped, j);
        }

        @Override
        public AST visitProduct(ProductContext ctx) {
            return new Regex.Product((Regex) visit(ctx.mealy_atomic()), parseQuotedLiteral(ctx.StringLiteral()));
        }

        @Override
        public AST visitAtomicLiteral(AtomicLiteralContext ctx) {
            return Regex.Atomic.fromString(parseQuotedLiteral(ctx.StringLiteral()),
                    new SourceCodePosition(ctx.StringLiteral().getSymbol()));
        }

        @Override
        public AST visitNoKleeneClosure(NoKleeneClosureContext ctx) {
            return visit(ctx.mealy_prod());
        }

        @Override
        public AST visitKleeneClosure(KleeneClosureContext ctx) {
            final TerminalNode w = ctx.Weight();
            Regex nested = (Regex) visit(ctx.mealy_prod());
            if (w == null) {
                return new Regex.Kleene(nested);
            } else {
                final int i = Integer.parseInt(w.getText());
                return new Regex.Kleene(new Regex.WeightAfter(nested, i));
            }
        }

        @Override
        public AST visitEndConcat(EndConcatContext ctx) {
            final TerminalNode w = ctx.Weight();
            Regex lhs = (Regex) visit(ctx.mealy_Kleene_closure());
            if (w == null) {
                return lhs;
            } else {
                final int i = Integer.parseInt(w.getText());
                return new Regex.WeightAfter(lhs, i);
            }
        }

        @Override
        public AST visitMoreConcat(MoreConcatContext ctx) {
            Regex lhs = (Regex) visit(ctx.mealy_Kleene_closure());
            Regex rhs = (Regex) visit(ctx.mealy_concat());

            final TerminalNode w = ctx.Weight();
            if (w == null) {
                return new Regex.Concat(lhs, rhs);
            } else {
                final int i = Integer.parseInt(w.getText());
                return new Regex.Concat(new Regex.WeightAfter(lhs, i), rhs);
            }
        }

        @Override
        public AST visitAtomicRange(AtomicRangeContext ctx) {
            final int[] range = ctx.Range().getText().codePoints().toArray();
            final int from, to;
            // [a-b] or [\a-b] or [a-\b] or [\a-\b]
            if (range[1] == '\\') {
                // [\a-b] or [\a-\b]
                from = escapeCharacter(range[2]);
                if (range[4] == '\\') {
                    // [\a-\b]
                    to = escapeCharacter(range[5]);
                } else {
                    // [\a-b]
                    to = range[4];
                }
            } else {
                // [a-b] or [a-\b]
                from = range[1];
                if (range[3] == '\\') {
                    // [a-\b]
                    to = escapeCharacter(range[4]);
                } else {
                    // [a-b]
                    to = range[3];
                }
            }
            return new Regex.Atomic(from, to, new SourceCodePosition(ctx.Range().getSymbol()));
        }

        @Override
        public AST visitMoreUnion(MoreUnionContext ctx) {
            Regex lhs = (Regex) visit(ctx.mealy_concat());
            Regex rhs = (Regex) visit(ctx.mealy_union());

            final TerminalNode w = ctx.Weight();
            if (w == null) {
                return new Regex.Union(lhs, rhs);
            } else {
                final int i = Integer.parseInt(w.getText());
                return new Regex.Union(new Regex.WeightBefore(lhs, i), rhs);
            }
        }

        @Override
        public AST visitEndUnion(EndUnionContext ctx) {
            Regex lhs = (Regex) visit(ctx.mealy_concat());
            final TerminalNode w = ctx.Weight();
            if (w == null) {
                return lhs;
            } else {
                final int i = Integer.parseInt(w.getText());
                return new Regex.WeightBefore(lhs, i);
            }
        }

        @Override
        public AST visitStart(StartContext ctx) {
            return visit(ctx.funcs());
        }
    }

    public static Funcs parse(String source) {
        return parse(CharStreams.fromString(source));
    }

    public static Funcs parse(CharStream source) {

        GrammarLexer lexer = new GrammarLexer(source);
        GrammarParser parser = new GrammarParser(new CommonTokenStream(lexer));
        parser.addErrorListener(new BaseErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line,
                    int charPositionInLine, String msg, RecognitionException e) {
                System.err.println("line " + line + ":" + charPositionInLine + " " + msg + " " + e);
            }
        });
        GrammarVisitor visitor = new GrammarVisitor();
        Funcs funcs = (Funcs) visitor.visit(parser.start());
        final Regex UNIVERSUM = new Regex.Atomic(1, Integer.MAX_VALUE, SourceCodePosition.NONE);
        final Regex HASH = new Regex.Atomic(0, 0, SourceCodePosition.NONE);
        return funcs.prependIfNotPresent(".", new TypeLanguage(UNIVERSUM), UNIVERSUM, SourceCodePosition.NONE)
                .prependIfNotPresent("#", new TypeLanguage(HASH), HASH, SourceCodePosition.NONE);

    }

    public static class AAA {
        final A ast;
        final String fName;
        final AlphOrStruct in;
        final AlphOrStruct out;

        public AAA(String fName, A ast, AlphOrStruct in, AlphOrStruct out) {
            this.fName = fName;
            this.ast = ast;
            this.in = in;
            this.out = out;
        }

        @Override
        public String toString() {
            return fName + ":" + in.name() + "->" + out.name();
        }

    }

    public static HashMap<String, AAA> eval(Funcs funcs) {
        HashMap<String, AAA> evaluated = new HashMap<>();
        HashMap<String, MealyParser.Struct> structs = new HashMap<>();
        for (Entry<String, StructDef> entry : funcs.structs.entrySet()) {
            structs.put(entry.getKey(), new CompiledStructDef(entry.getValue(), funcs.alphabets));
        }
        for (Func f : funcs.funcs) {
            final AlphOrStruct in;
            final AlphOrStruct out;

            TypeFunc mustBeFunc = (TypeFunc) funcs.types.get(f.getName());
            if (mustBeFunc == null) {
                in = UNICODE;
                out = UNICODE;
            } else {
                TypeVar input = (TypeVar) mustBeFunc.lhs;
                TypeVar output = (TypeVar) mustBeFunc.rhs;
                AlphOrStruct inT = funcs.alphabets.get(input.var);
                AlphOrStruct outT = funcs.alphabets.get(output.var);
                in = inT == null ? structs.get(input.var) : inT;
                out = outT == null ? structs.get(output.var) : outT;
            }
            evaluated.put(f.getName(), new AAA(f.getName(), f.body.substituteVars(evaluated, in, out), in, out));
        }
        return evaluated;
    }
}
