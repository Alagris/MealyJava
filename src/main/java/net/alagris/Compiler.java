/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package net.alagris;

import java.util.ArrayList;

import net.automatalib.commons.util.Pair;
import org.antlr.v4.runtime.BaseErrorListener;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.tree.TerminalNode;

import net.alagris.GrammarParser.EndFuncsContext;
import net.alagris.GrammarParser.FuncDefContext;
import net.alagris.GrammarParser.MealyAtomicCodepointContext;
import net.alagris.GrammarParser.MealyAtomicLiteralContext;
import net.alagris.GrammarParser.MealyAtomicNestedContext;
import net.alagris.GrammarParser.MealyAtomicRangeContext;
import net.alagris.GrammarParser.MealyAtomicVarIDContext;
import net.alagris.GrammarParser.MealyEndConcatContext;
import net.alagris.GrammarParser.MealyEndUnionContext;
import net.alagris.GrammarParser.MealyEpsilonProductContext;
import net.alagris.GrammarParser.MealyKleeneClosureContext;
import net.alagris.GrammarParser.MealyMoreConcatContext;
import net.alagris.GrammarParser.MealyMoreUnionContext;
import net.alagris.GrammarParser.MealyNoKleeneClosureContext;
import net.alagris.GrammarParser.MealyProductContext;
import net.alagris.GrammarParser.PlainAtomicCodepointContext;
import net.alagris.GrammarParser.PlainAtomicLiteralContext;
import net.alagris.GrammarParser.PlainAtomicNestedContext;
import net.alagris.GrammarParser.PlainAtomicRangeContext;
import net.alagris.GrammarParser.PlainAtomicVarIDContext;
import net.alagris.GrammarParser.PlainEndConcatContext;
import net.alagris.GrammarParser.PlainEndUnionContext;
import net.alagris.GrammarParser.PlainKleeneClosureContext;
import net.alagris.GrammarParser.PlainMoreConcatContext;
import net.alagris.GrammarParser.PlainMoreUnionContext;
import net.alagris.GrammarParser.PlainNoKleeneClosureContext;
import net.alagris.GrammarParser.StartContext;
import net.alagris.GrammarParser.TypeDefContext;
import net.alagris.GrammarParser.TypeJudgementContext;

public class Compiler{
    public interface AST<M, A, W> {}



    public static class Funcs<M, A,O extends Seq<A>, W> implements AST<M, A, W> {

        public final ArrayList<Mealy<M, A,O, W>> funcs = new ArrayList<>();
        public final ArrayList<Type<M, A,O, W>> types = new ArrayList<>();
        public Funcs<M, A,O, W> addMealy(Pos pos, Mealy<M, A,O, W> mealy, String name) {
            mealy.pos = pos;
            mealy.name = name;
            funcs.add(mealy);
            return this;
        }
        public Funcs<M, A, O,W> addType(Pos pos, Type<M, A,O, W> type, String name) {
            type.pos = pos;
            type.name = name;
            types.add(type);
            return this;
        }

    }
    public interface Func<M, A, O extends Seq<A>, W> extends AST<M, A, W> {
    }
    public static class Type<M, A, O extends Seq<A>, W> implements Func<M, A, O, W> {
        public final Regex<M, A, O, W> lhs, rhs;
        public Pos pos;
        public String name;
        public Type(Mealy<M, A,O, W> lhs, Mealy<M, A,O, W> rhs) {
            this.rhs = rhs.mealy;
            this.lhs = lhs.mealy;
        }
    }
    public static class Mealy<M, A,O extends Seq<A>, W> implements Func<M, A,O, W> {
        public Regex<M, A, O , W> mealy;
        public Pos pos;
        public String name;
        public Mealy(Regex<M, A, O, W> mealy) {
            this.mealy = mealy;
        }
    }

    public static int escapeCharacter(int c){
        switch(c){
            case 'b':
                return '\b';
            case 't':
                return '\t';
            case 'n':
                return '\n';
            case 'r':
                return '\r';
            case 'f':
                return '\f';
        }
        return c;
    }

    /**
     * Specifications for parsing. You can use this to customise parsing. For
     * instance, the standard parsing procedure takes string literals and produces
     * sequences of integers <tt>S&lt;Integer&gt;</tt>. It's possible, though it use
     * one's own custom notation of literals and parse complex
     * numbers/matrices/algebraic words/any Java objects.
     */
    public static interface ParseSpecs<M, A, O extends Seq<A>, W> {
        /**
         * this function takes parsing context and produced meta-information that should
         * be associated with given AST node. It can be used to obtain line number which
         * would later be useful for debugging and printing meaningful error messages.
         */
        public M metaInfoGenerator(TerminalNode parseNode);
        public M metaInfoGenerator(ParserRuleContext parseNode);
        public M metaInfoNone();
        /**
         * it takes terminal node associated with particular string literal that will be
         * used to build Product node in AST.
         */
        public O parseStr(TerminalNode parseNode) throws CompilationError;

        /**
         * Parses weights. In the source code weights are denoted with individual
         * integers. You may parse them to something else than numbers if you want.
         */
        public W parseW(TerminalNode parseNode) throws CompilationError ;

        /**
         * Parses ranges. In the source code ranges are denoted with pairs of unicode
         * codepoints. You may parse them to something else if you want.
         */
        public Pair<A,A> parseRange(int codepointFrom, int codepointTo);

        /**The largest range of values associated with the . dot */
        Pair<A,A> dot();

        /**The special value associated with the # symbol*/
        A hashtag();
    }

    /**
     * This parser has separate syntaxes for "plain" regular expressions (no output
     * and no weights) and weighted transducer regular expressions. If "plain"
     * regexes are also deterministic then they can be later used as types for other
     * expressions. Every "plain" regular expression defines certain regular
     * language. In type theory, a type is nothing more than set of all its
     * inhabitants. Hence regular language is a type in the universum of strings
     * over given alphabet. A powerset of regular language is a type in the
     * universum of regular languages. The type-theoretic notation
     *
     * <pre>
     * f : [a-z]*
     * </pre>
     * <p>
     * can also be seen as
     *
     * <pre>
     * f &in; P(L([a-z]*))
     * </pre>
     * <p>
     * where L denotes the regular language defined by regular expression and P is
     * the powerset function. This is in fact the same as writing
     *
     * <pre>
     * f &sub; L([a-z]*)
     * </pre>
     * <p>
     * The notation
     *
     * <pre>
     * f : [a-z]* &rarr; [0-9]*
     * </pre>
     * <p>
     * can be seen as
     *
     * <pre>
     * f &sub; L([a-z]*) &times; L([0-9]*)
     * </pre>
     * <p>
     * which is NOT the same as
     *
     * <pre>
     * f &in; P(L([a-z]*)) &times; P(L([9-0]*))
     * </pre>
     * <p>
     * Therefore the type system of this compiler needs a special treatment when
     * viewed from type-theoretical perspective. In fact, this system is
     * polymorphic, because it's possible for one term to have multiple types. For
     * instance
     *
     * <pre>
     * "abc" : .*
     * "abc" : [a-z]*
     * "abc" : [a-c]*
     * "abc" : "abc"
     * </pre>
     * <p>
     * in the order from coarsest to finest type. While the Regex class supports
     * different input and output alphabets, this parser requires both of them to be
     * the same. The universal alphabet is refered to as "A". It must be
     * this way, because otherwise transducer composition would become impossible.
     * Therefore "A" is like a sort and all the regular languages are types
     * inhabiting that sort.
     */
    private static class GrammarVisitor<M, A, O extends Seq<A>, W> extends GrammarBaseVisitor<AST<M, A, W>> {

        private final Funcs<M, A, O, W> definitions;
        private final ParseSpecs<M, A, O, W> specs;

        public GrammarVisitor(Funcs<M, A, O, W> definitions, ParseSpecs<M, A, O, W> specs) {
            this.definitions = definitions;
            this.specs = specs;

        }

        @Override
        public AST<M, A, W> visitEndFuncs(EndFuncsContext ctx) {
            return definitions;
        }

        @Override
        public AST<M, A, W> visitTypeDef(TypeDefContext ctx) {
            final Funcs<M, A, O, W> funcs = (Funcs<M, A, O, W>) visit(ctx.funcs());
            final String funcName = ctx.ID().getText();
            final Mealy<M, A, O,W> funcBody = (Mealy<M, A, O,W>) visit(ctx.plain_union());
            return funcs.addMealy(new Pos(ctx.ID().getSymbol()),funcBody,funcName);
        }

        @Override
        public AST<M, A, W> visitTypeJudgement(TypeJudgementContext ctx) {
            final Funcs<M, A, O, W> funcs = (Funcs<M, A, O, W>) visit(ctx.funcs());
            final Mealy<M, A, O,W> in = (Mealy<M, A, O,W>) visit(ctx.in);
            final Mealy<M, A, O,W> out = (Mealy<M, A, O,W>) visit(ctx.out);
            final String funcName = ctx.ID().getText();
            return funcs.addType(new Pos(ctx.ID().getSymbol()), new Type<>(in,out), funcName);
        }

        @Override
        public AST<M, A, W> visitFuncDef(FuncDefContext ctx) {
            final Funcs<M, A, O, W> funcs = (Funcs<M, A, O, W>) visit(ctx.funcs());
            final String funcName = ctx.ID().getText();
            final Mealy<M, A, O,W> funcBody = (Mealy<M, A, O,W>) visit(ctx.mealy_union());
            return funcs.addMealy(new Pos(ctx.ID().getSymbol()), funcBody, funcName);
        }

        @Override
        public Mealy<M, A, O,W> visitMealyEpsilonProduct(MealyEpsilonProductContext ctx) {
            return (Mealy<M, A, O,W>) visit(ctx.mealy_atomic());
        }

        @Override
        public Mealy<M, A, O,W> visitMealyAtomicVarID(MealyAtomicVarIDContext ctx) {
            return new Mealy<>(Regex.var(specs.metaInfoGenerator(ctx.ID()), ctx.ID().getText()));
        }

        @Override
        public Mealy<M, A, O,W> visitPlainAtomicVarID(PlainAtomicVarIDContext ctx) {
            return new Mealy<>(Regex.var(specs.metaInfoGenerator(ctx.ID()), ctx.ID().getText()));
        }

        @Override
        public Mealy<M, A, O,W> visitMealyAtomicNested(MealyAtomicNestedContext ctx) {
            return (Mealy<M, A, O,W>) visit(ctx.mealy_union());
        }

        @Override
        public Mealy<M, A, O,W> visitPlainAtomicNested(PlainAtomicNestedContext ctx) {
            return (Mealy<M, A, O,W>) visit(ctx.plain_union());
        }

        @Override
        public Mealy<M, A, O,W> visitMealyProduct(MealyProductContext ctx) {
            final Mealy<M, A, O,W> nested = (Mealy<M, A, O,W>) visit(ctx.mealy_atomic());

            final O out;
            try {
                out = specs.parseStr(ctx.StringLiteral());
            } catch (CompilationError e) {
                throw new RuntimeException(e);
            }
            nested.mealy =  Regex.product(specs.metaInfoGenerator(ctx.StringLiteral()), nested.mealy, out);
            return nested;
        }

        @Override
        public Mealy<M, A, O,W> visitPlainAtomicLiteral(PlainAtomicLiteralContext ctx) {
            try {
                return new Mealy<>(Regex.fromString(specs.metaInfoGenerator(ctx.StringLiteral()), specs.parseStr(ctx.StringLiteral())));
            } catch (CompilationError e) {
                throw new RuntimeException(e);
            }
        }

        @Override
        public Mealy<M, A, O,W> visitMealyAtomicLiteral(MealyAtomicLiteralContext ctx) {
            try {
                return new Mealy<>(Regex.fromString(specs.metaInfoGenerator(ctx.StringLiteral()), specs.parseStr(ctx.StringLiteral())));
            } catch (CompilationError e) {
                throw new RuntimeException(e);
            }
        }

        @Override
        public Mealy<M, A, O,W> visitMealyNoKleeneClosure(MealyNoKleeneClosureContext ctx) {
            return (Mealy<M, A, O,W>) visit(ctx.mealy_prod());
        }

        @Override
        public Mealy<M, A, O,W> visitPlainNoKleeneClosure(PlainNoKleeneClosureContext ctx) {
            return (Mealy<M, A, O,W>) visit(ctx.plain_atomic());
        }

        @Override
        public Mealy<M, A, O,W> visitMealyKleeneClosure(MealyKleeneClosureContext ctx) {
            final TerminalNode w = ctx.Weight();
            Mealy<M, A, O,W> nested = (Mealy<M, A, O,W>) visit(ctx.mealy_prod());
            M meta = specs.metaInfoGenerator(ctx);
            if (w == null) {
                nested.mealy = Regex.kleene(meta, nested.mealy);
            } else {
                try {
                    nested.mealy =  Regex.kleene(meta,
                            Regex.weightAfter(specs.metaInfoGenerator(w), nested.mealy, specs.parseW(w)));
                } catch (CompilationError e) {
                    throw new RuntimeException(e);
                }
            }
            return nested;
        }

        @Override
        public Mealy<M, A, O,W> visitPlainKleeneClosure(PlainKleeneClosureContext ctx) {
            Mealy<M, A, O,W> nested = (Mealy<M, A, O,W>) visit(ctx.plain_atomic());
            M meta = specs.metaInfoGenerator(ctx);
            nested.mealy = Regex.kleene(meta, nested.mealy);
            return nested;
        }

        @Override
        public Mealy<M, A, O,W> visitMealyEndConcat(MealyEndConcatContext ctx) {
            final TerminalNode w = ctx.Weight();
            Mealy<M, A, O,W> lhs = (Mealy<M, A, O,W>) visit(ctx.mealy_Kleene_closure());
            if (w != null) {
                try {
                    lhs.mealy = Regex.weightAfter(specs.metaInfoGenerator(w), lhs.mealy, specs.parseW(w));
                } catch (CompilationError e) {
                    throw new RuntimeException(e);
                }
            }
            return lhs;
        }

        @Override
        public Mealy<M, A, O,W> visitPlainEndConcat(PlainEndConcatContext ctx) {
            return (Mealy<M, A, O,W>) visit(ctx.plain_Kleene_closure());
        }

        @Override
        public AST<M, A, W> visitMealyMoreConcat(MealyMoreConcatContext ctx) {
            Mealy<M, A, O,W> lhs = (Mealy<M, A, O,W>) visit(ctx.mealy_Kleene_closure());
            Mealy<M, A, O,W> rhs = (Mealy<M, A, O,W>) visit(ctx.mealy_concat());
            M meta = specs.metaInfoGenerator(ctx);
            final TerminalNode w = ctx.Weight();
            if (w == null) {
                lhs.mealy = Regex.concat(meta, lhs.mealy, rhs.mealy);
            } else {
                try {
                    lhs.mealy = Regex.concat(meta, Regex.weightAfter(specs.metaInfoGenerator(w), lhs.mealy, specs.parseW(w)), rhs.mealy);
                } catch (CompilationError e) {
                    throw new RuntimeException(e);
                }
            }
            return lhs;
        }

        @Override
        public Mealy<M, A, O,W> visitPlainMoreConcat(PlainMoreConcatContext ctx) {
            Mealy<M, A, O,W> lhs = (Mealy<M, A, O,W>) visit(ctx.plain_Kleene_closure());
            Mealy<M, A, O,W> rhs = (Mealy<M, A, O,W>) visit(ctx.plain_concat());
            M meta = specs.metaInfoGenerator(ctx);
            lhs.mealy  = Regex.concat(meta, lhs.mealy, rhs.mealy);
            return lhs;
        }

        private <Out, W> Regex<M, A, Out, W> parseRange(TerminalNode node) {
            final int[] range = node.getText().codePoints().toArray();
            final int from, to;
            // [a-b] or [\a-b] or [a-\b] or [\a-\b]
            if (range[1] == '\\') {
                // [\a-b] or [\a-\b]
                from = escapeCharacter(range[2]);
                if (range[4] == '\\') {
                    // [\a-\b]
                    to = escapeCharacter(range[5]);
                } else {
                    // [\a-b]
                    to = range[4];
                }
            } else {
                // [a-b] or [a-\b]
                from = range[1];
                if (range[3] == '\\') {
                    // [a-\b]
                    to = escapeCharacter(range[4]);
                } else {
                    // [a-b]
                    to = range[3];
                }
            }
            Pair<A, A> r = specs.parseRange(from, to);
            M meta = specs.metaInfoGenerator(node);
            return Regex.atomic(meta, r.getFirst(), r.getSecond());
        }

        @Override
        public Mealy<M, A, O,W> visitPlainAtomicRange(PlainAtomicRangeContext ctx) {
            return new Mealy<>(parseRange(ctx.Range()));
        }

        @Override
        public Mealy<M, A, O,W> visitMealyAtomicRange(MealyAtomicRangeContext ctx) {
            return new Mealy<>(parseRange(ctx.Range()));
        }

        private <Out, W> Regex<M, A, Out, W> parseCodepoint(TerminalNode node) {
            String range = node.getText();
            range = range.substring(1, range.length() - 1);
            final int dashIdx = range.indexOf('-');
            final int from = Integer.parseInt(range.substring(0, dashIdx));
            final int to = Integer.parseInt(range.substring(dashIdx + 1));
            Pair<A, A> rangeIn = specs.parseRange(from, to);
            final M meta = specs.metaInfoGenerator(node);
            return Regex.atomic(meta, rangeIn.getFirst(), rangeIn.getSecond());
        }

        @Override
        public Mealy<M, A, O,W> visitMealyAtomicCodepoint(MealyAtomicCodepointContext ctx) {
            return new Mealy<>(parseCodepoint(ctx.Codepoint()));
        }

        @Override
        public Mealy<M, A, O,W> visitPlainAtomicCodepoint(PlainAtomicCodepointContext ctx) {
            return new Mealy<>(parseCodepoint(ctx.Codepoint()));
        }

        @Override
        public Mealy<M, A, O,W> visitMealyMoreUnion(MealyMoreUnionContext ctx) {
            Mealy<M, A, O,W> lhs = (Mealy<M, A, O,W>) visit(ctx.mealy_concat());
            Mealy<M, A, O,W> rhs = (Mealy<M, A, O,W>) visit(ctx.mealy_union());
            M meta = specs.metaInfoGenerator(ctx);
            final TerminalNode w = ctx.Weight();
            if (w == null) {
                lhs.mealy = Regex.union(meta, lhs.mealy, rhs.mealy);
            } else {
                try {
                    lhs.mealy = Regex.union(meta, Regex.weightBefore(specs.metaInfoGenerator(w), specs.parseW(w), lhs.mealy), rhs.mealy);
                } catch (CompilationError e) {
                    throw new RuntimeException(e);
                }
            }
            return lhs;
        }

        @Override
        public Mealy<M, A, O,W> visitPlainMoreUnion(PlainMoreUnionContext ctx) {
            Mealy<M, A, O,W> lhs = (Mealy<M, A, O,W>) visit(ctx.plain_concat());
            Mealy<M, A, O,W> rhs = (Mealy<M, A, O,W>) visit(ctx.plain_union());
            M meta = specs.metaInfoGenerator(ctx);
            lhs.mealy = Regex.union(meta, lhs.mealy, rhs.mealy);
            return lhs;
        }

        @Override
        public Mealy<M, A, O,W> visitMealyEndUnion(MealyEndUnionContext ctx) {
            Mealy<M, A, O,W> lhs = (Mealy<M, A, O,W>) visit(ctx.mealy_concat());
            final TerminalNode w = ctx.Weight();
            if (w != null) {
                try {
                    lhs.mealy = Regex.weightBefore(specs.metaInfoGenerator(w), specs.parseW(w), lhs.mealy);
                } catch (CompilationError e) {
                    throw new RuntimeException(e);
                }
            }
            return lhs;
        }

        @Override
        public Mealy<M, A, O,W> visitPlainEndUnion(PlainEndUnionContext ctx) {
            return (Mealy<M, A, O,W>) visit(ctx.plain_concat());
        }

        @Override
        public AST<M, A, W> visitStart(StartContext ctx) {
            return visit(ctx.funcs());
        }
    }

    public static <M, A, O extends Seq<A>, W> Funcs<M, A, O, W> parse(String source, ParseSpecs<M, A, O, W> specs) throws CompilationError {
        return parse(CharStreams.fromString(source), specs);
    }

    public static <M, A,O extends Seq<A>, W> Funcs<M, A, O, W> parse(CharStream source, ParseSpecs<M, A, O, W> specs) throws CompilationError {

        final GrammarLexer lexer = new GrammarLexer(source);
        final GrammarParser parser = new GrammarParser(new CommonTokenStream(lexer));
        parser.addErrorListener(new BaseErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) {
                System.err.println("line " + line + ":" + charPositionInLine + " " + msg + " " + e);
            }
        });
        final Funcs<M, A, O, W> funcs = new Funcs<>();
        Pair<A,A> dot = specs.dot();
        final Regex<M, A, O, W> UNIVERSUM = Regex.atomic(specs.metaInfoNone(),dot.getFirst(), dot.getSecond());

        final Regex<M, A, O, W> HASH = Regex.atomic(specs.metaInfoNone(),specs.hashtag(), specs.hashtag());
        funcs.addMealy(Pos.NONE, new Mealy<>(UNIVERSUM),".");
        funcs.addMealy(Pos.NONE, new Mealy<>(HASH), "#" );
        try {
            final GrammarVisitor<M, A, O, W> visitor = new GrammarVisitor<>(funcs, specs);
            visitor.visit(parser.start());
        }catch (RuntimeException e){
            if(e.getCause() instanceof  CompilationError){
                throw (CompilationError) e.getCause();
            }else{
                throw e;
            }
        }

        return funcs;

    }



}
